# ü¶Ü IMACANARD

IMACANARD est un jeu cr√©√© dans le cadre des cours *Programmation et algorithmique C++* et *Synth√®se d'images I*.

Il a √©t√© impl√©ment√© par Emilie DESOMBRE, Oc√©ane DRAPEAU et Claire GOBERT. Il fonctionne sur Windows et Linux.

## üé≤ R√®gles du jeu 

IMACANARD se joue au clavier. Le joueur se d√©place √† l'aide des fl√®ches du clavier <kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd>.

Il mine un bloc plein (n√©nuphar) avec <kbd>a</kbd>.

Il peut quitter le jeu √† tout moment avec <kbd>q</kbd>.

## üé® Th√®me du jeu

Le joueur incarne un canard qui cherche √† √©chapper √† des loutres. Il se d√©place dans une √©tendue d'eau et peut d√©truire des n√©nuphars. Lorsqu'il d√©truit des n√©nuphars, il peut collecter des ombres. Cependant, il ne peut pas aller sur les rochers. De plus, s'il prend un tourbillon, il perd la partie.

## üßê Sp√©cifications

### Joueur
Le joueur poss√®de une seule vie et perd si l'ennemi arrive sur sa case ou s'il tombe dans un pi√®ge. Il est repr√©sent√© par un canard jaune. Lorsqu'il mine, il y a un pourcentage de chances pour obtenir un objet.

### Ennemis
Les ennemis cherchent √† atteindre le joueur. Ils sont repr√©sent√©s par des loutres.

### Les blocs
Nous avons utilis√© la r√©partition des cases suivantes : 
- **Bloc vide (0):** repr√©sent√© par un bloc bleu (sans textures) et un bloc d'eau (avec textures). Le joueur peut aller dessus.

- **Obstacle (non minable) (1) :** repr√©sent√© par un bloc vert tr√®s fonc√© (sans textures) et un rocher sur un bloc d'eau (avec textures). Le joueur ne peut jamais aller dessus.

- **Bloc plein (minable) (2):** repr√©sent√© par un bloc vert (sans textures) et des fleurs sur un bloc d'eau (avec textures). Le joueur ne peut pas aller dessus √† moins de d√©truire le bloc.

- **Objet (4):** repr√©sent√© par un bleu tr√®s fonc√© (sans textures) et une ombre (avec textures). Le joueur peut collecter des objets.

- **Pi√®ge (5):** repr√©sent√© par un bloc bleu satur√© (sans textures) et un bloc d'eau et un tourbillon (avec textures). Le joueur peut aller dessus mais c'est la fin de la partie.

- **Acc√©l√©rateur (3):** repr√©sent√© par un bloc jaune-vert (sans textures) et des fleurs. Il donne au joueur un court boost de vitesse.

- **Ralentisseur (6):** repr√©sent√© par un bloc violet (sans textures) et des roseaux. Il diminue temporairement la vitesse du joueur.

Ces cases sont impl√©ment√©s √† l'aide d'une struct constitu√©e de positions et d'une valeur correspondant au type de bloc. 

### G√©n√©ration de la carte
La carte est g√©n√©r√© avec l'algorithme de g√©n√©ration proc√©durale cellular automata. Dans un premier temps, on y g√©n√®re des cases vides ou pleines (0 ou 1) avec 50% de chances chacune. Dans un second temps, on regarde les cases adjacentes individuellement, et on y ajuste leur caract√®re plein ou vide en fonction des voisins.

Puis on y ajoute des objets, des cases pi√®ges, des obstacles, et des modificateurs de vitesse.

Le joueur et les ennemis sont ajout√©s apr√®s la carte.

### Flow field pathfinding
La direction des ennemis est d√©finie grace √† l'algorithme de recherche Breadth-First Search.

### Interface graphique
Pour r√©aliser le menu et l'√©cran de fin de jeu, nous avons utilis√© la librairie imgui.
Le jeu contient donc un menu via lequel le joueur peut acc√©der √† une page de r√®gles et une page de param√®tres. Il peut s'il le souhaite changer la taille de la grille de jeu et le nombre d'ennemis pr√©sents.

## Post mortem

### Ce qui a bien fonctionn√©

L'algorithme de cellular automata a √©t√© assez simple √† impl√©menter, notamment par son explication d√©taill√©e dans le sujet du projet.

La coh√©sion au sein du groupe a permis √©galement de communiquer nos probl√®mes entre nous et de v√©rifier les codes des unes et des autres pour les r√©gler.

### Probl√®mes rencontr√©s

### Ennemis

La fonction de d√©placement des ennemis n'est pas optimis√©e suffisament, une meilleure gestion dans l'espace leur permettraient de suivre le joueur en permanence. Actuellement, il arrive que les ennemis se bloquent aux coins des murs.

#### Compilation

Il y a eu plusieurs probl√®mes de compilation : d'abord quand on a ajout√© les textures, une de nous avait la fen√™tre OpenGL qui n'arrivait pas √† charger. Ce qu'on croyait d'abord √™tre d√ª √† un manque de capacit√© de l'ordinateur √©tait en fait caus√© par l'utilisation de Clang au lieu de GCC.

#### Affichage de la carte
L'affichage de base de la map a √©t√© un probl√®me. Nous avons cherch√© √† recr√©er nous m√™me les objets mais nous nous sommes tromp√©s de GL_TRIANGLE_FAN et √ßa nous a renvoy√© quelques erreurs ![image](./doc/screenshots/screendisplay.png)

Puis ce fut au tour des buffers. En rentrant un mauvais nombre de coordonn√©es, notre carte s'est d√©form√©e.

![image](/doc/screenshots/screendisplay2.png)

#### Les textures
L'affichage des textures a √©t√© tr√®s compliqu√©. Nous voulions les initialiser, puis les utiliser en les stockant dans une liste. Cependant, les textures, de par leur composition "s'auto d√©truisaient", lorsqu'on cherchait √† y acc√©der, elles ne s'affichaient pas. De plus, aucun message d'erreur n'√©tait renvoy√©, ne permettant pas de comprendre ce qui n'allait pas.

Apr√®s des jours d'exp√©rimentation, nous avons fini par demander de l'aide √† Enguerrand De Smet. La solution a finalement √©t√© de rajouter des lignes manquantes √† un fichier de la librairie. 

#### Les sprites

L'affichage des sprites √©tait √©galement compliqu√©. En effet, il fallait normaliser les images qui par d√©faut n'√©taient pas dans le m√™me rep√®re que les textures. Par ailleurs, le lien entre le fait que les coordonn√©es de la texture dans le buffer correspondait aux coordonn√©es du sprite √† utiliser a √©t√© compliqu√© √† comprendre. C'est par hasard que nous avons fait la correspondance, lorsque nous avons utilis√© le mauvais de tableau de coordonn√©es dans le buffer.

![image](/doc/screenshots/screendisplay6.png)

Par ailleurs, les images √©taient √† l'envers. Nous avons ajout√© ```cpp stbi_set_flip_vertically_on_load(true);```
pour retourner les images.

### Avec plus de temps

Avec plus de temps, nous aurions aim√© approfondir un peu plus le jeu et le rendre plus efficace. 

En synth√®se d'images, nous aurions voulu rajouter des animations et rectifier l'affichage des sprites qui est pour le moment positionn√© √† la main.

En algorithmique, nous aurions voulu am√©liorer la g√©n√©ration de la carte et, en g√©n√©ral, reorganiser notre code pour √™tre plus efficace, notamment en utilisant plus de r√©f√©rences.